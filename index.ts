/**
 * 文件：index.ts
 * 作用：项目主入口文件，提供文档同步示例和快速测试功能
 * 核心功能：演示如何使用DocSyncPipeline同步Petstore Swagger文档并生成客户端代码
 * 数据流转：Swagger URL → 文档获取 → 管道处理 → 客户端代码生成 → 文件输出
 */

import { fileURLToPath } from 'node:url';
import { basename, resolve } from 'node:path';

import { DocSyncPipeline } from './src/pipeline/index.js';
import type { DocSyncPipelineResult, DocSyncPipelineRunOptions } from './src/pipeline/types.js';

/** Petstore Swagger 文档的公开 URL，用于演示和测试 */
const PETSTORE_SWAGGER_URL = 'https://petstore.swagger.io/v2/swagger.json';

/**
 * 创建文档同步管道的配置选项
 * 
 * @returns 配置了Petstore Swagger源和输出目录的管道选项
 * 
 * 配置说明：
 * - invoke.sources: 配置文档源为Swagger类型，指向Petstore API
 * - output.outputDir: 指定生成的客户端代码输出目录
 * - stageLogger: 关闭详细的阶段日志输出
 */
function createPipelineOptions(): DocSyncPipelineRunOptions {
  return {
    invoke: {
      sources: [
        {
          type: 'swagger',
          name: 'petstore',
          options: { url: PETSTORE_SWAGGER_URL },
          metadata: { primary: true },
        },
      ],
    },
    output: {
      outputDir: './client',
    },
    stageLogger: false,
  };
}

/**
 * 同步Petstore Swagger文档的主要函数
 * 
 * 核心功能：
 * 1. 创建文档同步管道实例
 * 2. 从远程URL获取Swagger文档
 * 3. 解析并转换为标准ServiceDefinition模型
 * 4. 生成TypeScript客户端代码包
 * 5. 输出到指定目录
 * 
 * 数据流转：
 * Swagger JSON → 解析器 → ServiceDefinition → 代码生成器 → Bundle → 文件系统
 * 
 * @returns 包含服务定义、生成包等信息的管道执行结果
 */
export async function syncPetstoreSwagger(): Promise<DocSyncPipelineResult> {
  // 创建管道实例，不启用详细日志
  const pipeline = new DocSyncPipeline(undefined, undefined, false);
  const options = createPipelineOptions();

  // 解析输出目录的绝对路径
  const resolvedOutput = options.output?.outputDir
    ? resolve(options.output.outputDir)
    : undefined;

  console.log(`[DocSyncPipeline] Fetching Swagger document from ${PETSTORE_SWAGGER_URL}`);
  // 执行管道，完成文档同步和代码生成
  const result = await pipeline.run(options);

  // 统计处理的端点数量
  const endpointCount = result.serviceDefinition?.endpoints.length ?? 0;
  console.log(`[DocSyncPipeline] Processed ${endpointCount} endpoints`);

  // 输出生成结果的统计信息
  const bundle = result.generatedBundle;
  if (bundle && resolvedOutput) {
    console.log(
      `[DocSyncPipeline] Generated bundle with ${bundle.files.length} files → ${resolvedOutput}`,
    );
  } else if (bundle) {
    console.log(`[DocSyncPipeline] Generated bundle with ${bundle.files.length} files`);
  } else {
    console.warn('[DocSyncPipeline] No bundle generated by the generator stage');
  }

  return result;
}

/**
 * 主执行函数
 * 
 * 作用：当文件直接运行时的入口点，执行Petstore Swagger同步示例
 * 包含错误处理，确保异常情况下的适当日志输出
 */
async function main() {
  try {
    await syncPetstoreSwagger();
    console.log('[DocSyncPipeline] Completed successfully');
  } catch (error) {
    console.error('[DocSyncPipeline] Failed to complete synchronization');
    throw error;
  }
}

/**
 * 检测当前文件是否为直接执行的入口点
 * 
 * 实现原理：
 * 1. 比较当前文件的URL与process.argv[1]（执行的脚本路径）
 * 2. 支持ESM模块的import.meta.url和CommonJS兼容性
 * 3. 提供fallback机制，在URL解析失败时使用文件名比较
 */
const isEntrypoint = (() => {
  if (typeof process === 'undefined' || !process.argv?.[1]) return false;
  try {
    return fileURLToPath(import.meta.url) === resolve(process.argv[1]);
  } catch {
    return basename(import.meta.url) === basename(process.argv[1]);
  }
})();

// 如果当前文件被直接执行，则运行示例
if (isEntrypoint) {
  await main();
}
